package tld.victim.webapp_java_spring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import tld.victim.webapp_java_spring.blacklist.Blacklist;
import tld.victim.webapp_java_spring.blacklist.BlacklistConfDataHelper;

import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Optional;

@Controller 
@RequestMapping(path="/sqlidemo") // This means URL's start with /sqlidemo (after Application path)
public class MainController {
    @Autowired // This means to get the bean called userRepository 
    // Which is autogenerated by Spring, we will use ist to handle the data
    private UserRepository userRepository;

    BlacklistConfDataHelper blacklistConfDataHelper = BlacklistConfDataHelper.get();

    // Autowired datasource for the sqli.
    @Autowired
    DataSource dataSource;

    @Autowired
    EntityManager em;

    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam String username, 
            @RequestParam String password) {
            // @ResponseBody means the returned String is the response, not a view name
            // @RequestParam means it is a parameter from the GET or POST Request

            User n = new User();
            n.setUsername(username);
            n.setPassword(password);
            userRepository.save(n);
            return "Saved";
        }

    @DeleteMapping(path="/del")
    public @ResponseBody String delUser(@RequestParam String username) {
        List<User> foundUsernames = userRepository.findByUsername(username);
        userRepository.deleteAll(foundUsernames);
        if (foundUsernames.isEmpty() == true)
            return "Nothing to delete";
        else
            return "Deleted";
    }

    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    @RequestMapping(path="/safebyid")
    public @ResponseBody String safeGetUserById(@RequestParam Integer id)
    {
        Optional<User> optional = userRepository.findById(id);
        return optional.get().getUsername();

    }

    @RequestMapping(path="/safebyusername")
    public @ResponseBody String safeGetUserByUsername(@RequestParam String username)
    {
        List<User> users = userRepository.findByUsername(username);
        String return_string = "";
        for (User user : users)
        {return_string = return_string + user.getId();};
        return return_string;

    }

    @RequestMapping(path="/vulnbyid")
    public @ResponseBody String unsafeGetUserById(@RequestParam String id, @RequestParam(required=false) String[] blacklistconfig) {
        String[] originalquery = {
                "select * from ",
                "user",
                " where id = '",
                id,
                "' group by username order by username asc"};

        // for test purposes if uppercase black list is used set query to an upper case one
        if (blacklistConfDataHelper.confContains(blacklistconfig, blacklistConfDataHelper.CONFSTRING_BLOCK_ANY_LOWERCASE))
        {
            originalquery = new String[] {originalquery[0].toUpperCase(), "user", originalquery[2].toUpperCase(), id, "'"};
        }

        String response_out = "";
        Blacklist blacklist = new Blacklist(blacklistconfig, originalquery,1,  3);

        response_out = blacklist.getLog();
        if (blacklist.isQueryBlocked() == false)
        {
            ResultSet rs = null;
            try {
                Connection c = dataSource.getConnection();
                rs = c.createStatement().executeQuery(blacklist.getBlacklistedQuery());

                while (rs.next()) {
                    response_out = response_out + rs.getString("username");
                }
                rs.close();
                c.close();
            }
            catch (SQLException ex)
            {
                response_out = response_out + "\n" +
                               blacklist.getBlacklistedQuery() + "\n" + "\n" +
                               ex.getMessage() + "\n" +
                               "Error Code: \t"  + ex.getErrorCode() + "\n" +
                               "SQL State: \t" + ex.getSQLState() + "\n";
            }
        }
        return response_out;
    }

    @RequestMapping(path="/vulnbyid2")
    public @ResponseBody String unsafeGetUserByIdJPA(@RequestParam String id) throws SQLException {
        String jpql = "select username from User where id = '"+ id + "'";
        TypedQuery<String> q = em.createQuery(jpql, String.class);
        return q.getResultList().get(0);
    }

    @RequestMapping(path="/safebyid2")
    public @ResponseBody String safeGetUserByIdJPA(@RequestParam String id) throws SQLException {
        String jpql = "select username from User where id = :id";
        TypedQuery<String> q = em.createQuery(jpql, String.class).setParameter("id",Integer.parseInt(id));
        return q.getResultList().get(0);
    }
}
